// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ----- //
// PwmIn //
// ----- //

#define PwmIn_wrap_target 0
#define PwmIn_wrap 13

static const uint16_t PwmIn_program_instructions[] = {
            //     .wrap_target
    0xa04b, //  0: mov    y, !null                   
    0xa02b, //  1: mov    x, !null                   
    0x2020, //  2: wait   0 pin, 0                   
    0x20a0, //  3: wait   1 pin, 0                   
    0x0086, //  4: jmp    y--, 6                     
    0x0000, //  5: jmp    0                          
    0x00c4, //  6: jmp    pin, 4                     
    0x00ca, //  7: jmp    pin, 10                    
    0x0047, //  8: jmp    x--, 7                     
    0x0000, //  9: jmp    0                          
    0xa0ca, // 10: mov    isr, !y                    
    0x8000, // 11: push   noblock                    
    0xa0c9, // 12: mov    isr, !x                    
    0x8000, // 13: push   noblock                    
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program PwmIn_program = {
    .instructions = PwmIn_program_instructions,
    .length = 14,
    .origin = -1,
};

static inline pio_sm_config PwmIn_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + PwmIn_wrap_target, offset + PwmIn_wrap);
    return c;
}
#endif

/*

#Interprete de PIO 
# https://wokwi.com/tools/pioasm

#CÃ³digo original
# https://github.com/GitJer/Some_RPI-Pico_stuff/blob/main/PwmIn/PwmIn.pio

.program PwmIn

; algorithm:

; loop:
;    reset y, the 'timer' for the pulsewidth (high period)
;    reset x, the 'timer' for the low period. (high + low = period)
;    wait for a 0, then wait for a 1: this is the rising edge
;    loop: 
;       decrement y timer
;       test for falling edge 
;    y timer value is the pulse width (actually, (0xFFFFFFFF - y)*2/125MHz is the pulse width)
;    loop:
;       test for rising edge
;       decrement x timer
;    x timer is the low period (actually, (0xFFFFFFFF - x)*2/125MHz is the low period)
;    push both y and x to the Rx FIFO

.wrap_target
start:
    mov y ~NULL         ; start with the value 0xFFFFFFFF
    mov x ~NULL         ; start with the value 0xFFFFFFFF
    wait 0 pin 0        ; wait for a 0
    wait 1 pin 0        ; wait for a 1, now we really have the rising edge
timer_hp:               ; loop for high period
    jmp y-- test        ; count down for pulse width
    jmp start           ; timer has reached 0, stop count down of pulse, restart
test:
    jmp pin timer_hp    ; test if the pin is still 1, if so, continue counting down
timer_lp:               ; loop for low period
    jmp pin timerstop   ; if the pin has become 1, the period is over, stop count down
    jmp x-- timer_lp    ; if not: count down
    jmp start           ; timer has reached 0, stop count down of low period, restart
timerstop:
    mov ISR ~y          ; move the value ~y to the ISR: the high period (pulsewidth) (0xFFFFFFFF-y)
    push noblock        ; push the ISR into the Rx FIFO
    mov ISR ~x          ; move the value ~x to the ISR: the low period (0xFFFFFFFF-x)
    push noblock        ; push the ISR into the Rx FIFO
.wrap

*/